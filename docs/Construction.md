# SIN Documentation

_Note: This document describes an aspect of the language which has not yet been fully implemented._

## Type Construction

An important concept in SIN, especially when dealing with structures, is _construction._ While constructors and destructors do not exist in the language, this functionality is present through the `construct` keyword and through _default type construction._ The purpose of this concept is  to ensure that every type is in a valid state upon its allocation.

### Default Construction

In SIN, data may not be referenced before it is initialized, either with an assignment using `let` or with alloc-init syntax (e.g., `alloc int x: 10`). However, the compiler will not prevent you from doing something like the following:

    alloc int x;
    if (some_condition) {
        let x = 30;
    }
    alloc ptr<int> p: $x;
    alloc int y: *p;

What is the value of `y`? It depends on the truthiness of `some_condition`; if `true`, `y` will be equal to 30. But if not, then what _does_ `y` equal? In some languages, this might be undefined or maybe even illegal behavior. In this example, `y` is assigned with the value `x`, which has not been initialized. However, the compiler has no way of knowing whether a pointer is pointing to uninitialized data.

If `p`'s allocation had occurred immediately after `x`'s, then the compiler _could_ issue an error because `x` was _definitely_ left uninitialized. However, this behavior is not illegal in SIN because of _default type construction._ In order to maintain data safety and preventing the use of garbage data, all data in SIN will be constructed to some default value if it is left uninitialized in the allocation. However, the compiler will still issue errors if some piece of uninitialized data is accessed (unless via a pointer). As such, following SIN's type construction rules, in the above example, `y` will be equal to 0.

The only thing default construction does is initialize all of the bytes making up the object to `0x00`. The following is a table of default constructed values:

| Type | Default value |
| ---- | ------------- |
| All integral types | `0` |
| Pointers | `null` |
| All floating-point types | `+0.0` |
| `string` | Empty string (a null byte) with length 0 |
| `char` | `\0` |
| Arrays, tuples, and structs | All members are constructed according to its type rules; if an array is marked `dynamic`, it will contain no elements |

However, not all data may be legally default-constructed; some types must be initialized in their allocation:

* All data marked `const` must be initialized with a constant expression (a `constexpr` or literal)
* All references (`ref<T>`) must supply the address of the referent using alloc-init syntax

### The `construct` keyword

Perhaps the most important aspect of `construct` is its use with structs. Unlike, for example, Java, where default constructors are automatically generated by the compiler (if no other constructor is available), the SIN compiler does not provide any such method. This means that if a struct is allocated, and only some of its members are initialized, the struct itself will have been seen as initialized in the compiler when some of its fields may not have been. As an example, take the following example where we initialize some struct `point`, with integer members `x, y, z`:

    alloc point p;
    let p.x = 10;
    alloc int n: p.y;

In this case, the compiler will allow the use of `p.y` because it will consider the struct `p` as having been initialized -- it is not required to track every individual member. However, it is obvious that `p.y` will really be uninitialized by any expression and instead will contain its type's default value (zero). To solve this problem, SIN utilizes _type construction_ and allows for a Rust-like construction to be specified when a struct is allocated.

So, in the above example, we could say:

    alloc point p: construct point {
        x: 10,
        y: 0,
    };

Like in Rust, the `construct` expression must initialize _every_ member. However, since `construct` was not used in the initial example, the struct would have been default-constructed such that all members would be set equal to 0. If a struct contains reference members, it _must_ use alloc-init syntax; default construction of such structs is not allowed.

There are three scenarios where the `construct` keyword may be used:

* Initialization with alloc-init syntax
* Whole struct assignment or initialization
* Struct replacement via anonymous struct creation

The above example used alloc-init syntax. If a struct contains references, this will still work because a new struct is created that replaces the old one. For example, this code is valid:

    alloc int x: 10;
    alloc int y: 10;
    def struct m {
        alloc ref<int> r;
    }

    // alloc-init intialization
    alloc m m1: construct { // saying 'construct m' is not strictly necessary, 
                            // as it must obviously be constructing an object of type 'm'
        r: $x,
    };

    // whole struct assignment / initialization
    alloc point origin;
    construct origin {
        x: 0,
        y: 0,
        z: 0,
    };

    // struct replacement with an anonymous struct
    let m1 = construct point {
        r: $y,
    };

Typically, references are immutable, but in this instance, the entire struct `m1` is deleted and replaced with a new object. This means that we aren't really altering its references, we are replacing them. However, this means that we could _not_ do the following afterwards

    construct m1 {
        r: $x,
    };

because `r` has already been assigned as a reference to `y` and is now syntactically an integer. Utilizing `construct` can be used to assign all members of a struct, and so we _could_ say

    construct m1 {
        r: 50,
    };

This is because a `construct` _statement_ acts as a regular assignment if the data was already initialized; it does not create a new object. A `construct` _expression_ will create a new, anonymous object. In both cases, the compiler will utilize the address of the existing object and construct the object in its place.

### The `default` keyword

Sometimes, a user may want to only intialize some members in a structure's `construct` expression (e.g., its `ref` members) and default-construct the rest. In such cases, it can be tedious to write out every member's initialization. To work around this, SIN also allows the use of the `default` keyword inside of a struct to explicitly default-initialize all other members. For example, the following struct:

    def struct ex
    {
        alloc ref<array<int> > r;
        alloc int x;
        alloc int y;
        alloc int z;
        alloc float f;
        alloc float d &long;
    }

can be initialized as follows:

    alloc ex e: construct {
        r: some_array,
        d: 1.2345,
        default
    };

This will initialize the `r` and `d` members explicitly, and default-construct all other members. Regular construction rules apply, meaning it is still required to initialize references. For example, this would be illegal:

    alloc ex c: construct {
        x: 10,
        default     // ERR: reference member 'r' must be explicitly initialized 
    };

You may also utilize the `default` keyword redundantly to signify a particular variable should be default-constructed. However, this is generally unnecessary. For example:

    alloc int x: default;   // default-initializes x

This usage will cause a compiler note to be generated alerting the programmer to this redundancy.
